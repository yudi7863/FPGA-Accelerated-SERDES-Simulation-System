/* 
 * "Small Hello World" example. 
 * 
 * This example prints 'Hello from Nios II' to the STDOUT stream. It runs on
 * the Nios II 'standard', 'full_featured', 'fast', and 'low_cost' example 
 * designs. It requires a STDOUT  device in your system's hardware. 
 *
 * The purpose of this example is to demonstrate the smallest possible Hello 
 * World application, using the Nios II HAL library.  The memory footprint
 * of this hosted application is ~332 bytes by default using the standard 
 * reference design.  For a more fully featured Hello World application
 * example, see the example titled "Hello World".
 *
 * The memory footprint of this example has been reduced by making the
 * following changes to the normal "Hello World" example.
 * Check in the Nios II Software Developers Manual for a more complete 
 * description.
 * 
 * In the SW Application project (small_hello_world):
 *
 *  - In the C/C++ Build page
 * 
 *    - Set the Optimization Level to -Os
 * 
 * In System Library project (small_hello_world_syslib):
 *  - In the C/C++ Build page
 * 
 *    - Set the Optimization Level to -Os
 * 
 *    - Define the preprocessor option ALT_NO_INSTRUCTION_EMULATION 
 *      This removes software exception handling, which means that you cannot 
 *      run code compiled for Nios II cpu with a hardware multiplier on a core 
 *      without a the multiply unit. Check the Nios II Software Developers 
 *      Manual for more details.
 *
 *  - In the System Library page:
 *    - Set Periodic system timer and Timestamp timer to none
 *      This prevents the automatic inclusion of the timer driver.
 *
 *    - Set Max file descriptors to 4
 *      This reduces the size of the file handle pool.
 *
 *    - Check Main function does not exit
 *    - Uncheck Clean exit (flush buffers)
 *      This removes the unneeded call to exit when main returns, since it
 *      won't.
 *
 *    - Check Don't use C++
 *      This builds without the C++ support code.
 *
 *    - Check Small C library
 *      This uses a reduced functionality C library, which lacks  
 *      support for buffering, file IO, floating point and getch(), etc. 
 *      Check the Nios II Software Developers Manual for a complete list.
 *
 *    - Check Reduced device drivers
 *      This uses reduced functionality drivers if they're available. For the
 *      standard design this means you get polled UART and JTAG UART drivers,
 *      no support for the LCD driver and you lose the ability to program 
 *      CFI compliant flash devices.
 *
 *    - Check Access device drivers directly
 *      This bypasses the device file system to access device drivers directly.
 *      This eliminates the space required for the device file system services.
 *      It also provides a HAL version of libc services that access the drivers
 *      directly, further reducing space. Only a limited number of libc
 *      functions are available in this configuration.
 *
 *    - Use ALT versions of stdio routines:
 *
 *           Function                  Description
 *        ===============  =====================================
 *        alt_printf       Only supports %s, %x, and %c ( < 1 Kbyte)
 *        alt_putstr       Smaller overhead than puts with direct drivers
 *                         Note this function doesn't add a newline.
 *        alt_putchar      Smaller overhead than putchar with direct drivers
 *        alt_getchar      Smaller overhead than getchar with direct drivers
 *
 */


#include "sys/alt_stdio.h"
#include "HAL/inc/io.h"
#include "system.h"
#include <stdint.h>
volatile uint64_t SIGMA10 [128] = {

		0x000041ed3c8eef63,
		0x000098f6714ab145,
		0x00010b5b7c0f13fb,
		0x0001a10b3f59c4ab,
		0x0002640aac320bba,
		0x000360f0ad53a112,
		0x0004a77a2d4cd28b,
		0x00064b39af27358d,
		0x00086466223731d5,
		0x000b10ccb807ba03,
		0x000e74e98860a9e7,
		0x0012bd2ab3b83a15,
		0x00181f616ff7738c,
		0x001edc63f5f246b5,
		0x002741e296d956cc,
		0x0031ac7150203c9c,
		0x003e89c5fa8e9554,
		0x004e5b29a8943164,
		0x0061b819ecad385c,
		0x007951149193876c,
		0x0095f285cd837ad8,
		0x00b887ce2e7c6328,
		0x00e21e527265cb78,
		0x0113e88443f0af40,
		0x014f40cf821590d0,
		0x0195ac5468233ba0,
		0x01e8dd53c0eeeae0,
		0x024ab52f6f736220,
		0x02bd45df2cd622a0,
		0x0342d2b795228e40,
		0x03ddd060a8236c00,
		0x0490e3d8f0f64340,
		0x055ee063c08cc080,
		0x064ac44372f51d00,
		0x0757b424b23a3800,
		0x0888f5252623b780,
		0x09e1e56702942b80,
		0x0b65f32b63438c00,
		0x0d1892773df6fd00,
		0x0efd3151bc24bd80,
		0x11172ab6bf216e00,
		0x1369b864d90f0c00,
		0x15f7e3babaa78100,
		0x18c475e48690b900,
		0x1bd1e7a527fd1900,
		0x1f22511230635e00,
		0x22b759a15bb43a00,
		0x269228ed2e890400,
		0x2ab35899bde17200,
		0x2f1ae7c336aa2600,
		0x33c8305ce7d81600,
		0x38b9dee13dd39000,
		0x3dedeca944b97200,
		0x43619d3508d61800,
		0x49117e9dcf8a8c00,
		0x4ef96d5811384c00,
		0x55149b55e39a7c00,
		0x5b5d9a83cd59b000,
		0x61ce6a828916d800,
		0x68608968e08e8c00,
		0x6f0d0742576a2000,
		0x75cc9beaadb30000,
		0x7c97bed41c245000,
		0x8366c03743aa4000,
		0x8a31e320b21b9000,
		0x90f177c908647000,
		0x979df5a27f400000,
		0x9e301488d6b7b000,
		0xa4a0e4879274d800,
		0xaae9e3b57c340800,
		0xb10511b34e963800,
		0xb6ed006d9043f800,
		0xbc9ce1d656f87000,
		0xc21092621b151000,
		0xc744a02a21faf000,
		0xcc364eae77f66800,
		0xd0e3974829245800,
		0xd54b2671a1ed1000,
		0xd96c561e31458000,
		0xdd47256a041a4800,
		0xe0dc2df92f6b2000,
		0xe42c976637d16800,
		0xe73a0926d93dc800,
		0xea069b50a5270000,
		0xec94c6a686bf7800,
		0xeee75454a0ad1800,
		0xf1014db9a3a9c800,
		0xf2e5ec9421d78800,
		0xf4988bdffc8af800,
		0xf61c99a45d3a5800,
		0xf77589e639aac800,
		0xf8a6cae6ad944800,
		0xf9b3bac7ecd96000,
		0xfa9f9ea79f41c000,
		0xfb6d9b326ed84000,
		0xfc20aeaab7ab1800,
		0xfcbbac53caabf800,
		0xfd41392c32f86000,
		0xfdb3c9dbf05b2000,
		0xfe15a1b79edf9800,
		0xfe68d2b6f7ab4800,
		0xfeaf3e3bddb8f000,
		0xfeea96871bddd000,
		0xff1c60b8ed68b000,
		0xff45f73d31521800,
		0xff688c85924b0000,
		0xff852df6ce3af000,
		0xff9cc6f173214000,
		0xffb023e1b73a4800,
		0xffbff545653fe800,
		0xffccd29a0fae4000,
		0xffd73d28c8f52800,
		0xffdfa2a769dc3800,
		0xffe65fa9efd70800,
		0xffebc1e0ac164000,
		0xfff00a21d76dd000,
		0xfff36e3ea7c6c000,
		0xfff61aa53d974800,
		0xfff833d1b0a74800,
		0xfff9d7913281a800,
		0xfffb1e1ab27ad800,
		0xfffc1b00b39c7000,
		0xfffcde002074b800,
		0xfffd73afe3bf6800,
		0xfffde614ee83c800,
		0xfffe3d1e233f8800,
		0xfffe7f0b5fce7800,
		0xfffeb0c299df0000


};

volatile uint64_t PULSE_RESPONSE_VALS [2] = { //1, 0.0
		//0x0000000001000008, //1, 0.0
		//0x0000000000000008,
		//0x0000000001000008, //1, 0.1
		//0x00000000001a0008
		//0x0000000001000008,//1, 0.2
		//0x0000000000330008
		0x0000000001000008, //1, 0.3
		0x00000000004d0008
		//0x0000000001000008, // 0.4
		//0x0000000000660008
		//0x0000000001000008, //1, 0.8
		//0x0000000000cd0008
		//0x0000000001000008,//1, 0.5
		//0x0000000000800008

		/////////////////////pulse_response length == 3:
		0x0000000001000008, // 1, 0.4, 0.3
		0x0000000000660008,
		0x00000000004d0008,
		//0x0000000001000008, // 1, 0.2, 0.1
		//0x0000000000330008,
		//0x00000000001a0008,

};

int main()
{
  //printf("Hello from Nios II!\n");
	//assigning values to SIGMA6:


	volatile uint32_t * ocm_base = (uint32_t *) ON_CHIP_MEM_BASE;
	volatile uint32_t total_bits = 0;// = 0x1234DEAD;

	//writing to ocm to see if it works:
	//*(ocm_base) = value;
	//*(ocm_base+1) = value;
	//*(ocm_base+2) = value;
	//*(ocm_base+3) = value;

	//writing sigma_6 values into ocm:
	for(int i = 0; i < 128; i = i + 1){ //this starts at 1C0;
		*(ocm_base+i*4+864) = (uint32_t)(SIGMA10[i] >> 32); //upper
		*(ocm_base+i*4+1+864) = (uint32_t)SIGMA10[i]; //lower //1c0
	}
	//writing channel: channel starting at 1580 and 1584:  1376:
	for(int i = 0; i < 2; i = i + 1){
		*(ocm_base+(i)*4+1376) = (uint32_t)(PULSE_RESPONSE_VALS[i] >> 32); //upper
		*(ocm_base+(i)*4+1+1376) = (uint32_t)PULSE_RESPONSE_VALS[i]; //lower //1c0
	}

	//found the location of the actual hex file!!
	// the noise channel location starts at D80, D84
	//conversion: D80 =
	//D84 =
	//1600 =
	//2c0 maps to 1600
	volatile uint32_t total_bit_errors = 0;
	volatile double BER = 0.0;
	//printing a range of values to see where the total_bits are located
	volatile int count = 0; //should be at 144
	//while(count < 146){
		//total_bits = *(ocm_base+130+count);
		//total_bit_errors = *(ocm_base+404);
		*(ocm_base+1440) = 0x1;
		*(ocm_base+1440) = 0x2;

		total_bit_errors = *(ocm_base+864);
		total_bit_errors = *(ocm_base+865); //this is 8 //this is 6991a1e1
		total_bits = *(ocm_base+1408); //this is 12 //this is 2C0 in quartus total bits:
		total_bit_errors = *(ocm_base+1412); // this is 14 1610
//count = count + 2;
		//BER = ((double) total_bit_errors) / ((double) total_bits);
		//alt_printf("total bits: %x\n", total_bits);
		//alt_printf("total bit errors: %x\n", total_bit_errors);
	//}
	alt_printf("total bit errors: %x\n", total_bit_errors);
  return 0;
}
