/* 
 * "Small Hello World" example. 
 * 
 * This example prints 'Hello from Nios II' to the STDOUT stream. It runs on
 * the Nios II 'standard', 'full_featured', 'fast', and 'low_cost' example 
 * designs. It requires a STDOUT  device in your system's hardware. 
 *
 * The purpose of this example is to demonstrate the smallest possible Hello 
 * World application, using the Nios II HAL library.  The memory footprint
 * of this hosted application is ~332 bytes by default using the standard 
 * reference design.  For a more fully featured Hello World application
 * example, see the example titled "Hello World".
 *
 * The memory footprint of this example has been reduced by making the
 * following changes to the normal "Hello World" example.
 * Check in the Nios II Software Developers Manual for a more complete 
 * description.
 * 
 * In the SW Application project (small_hello_world):
 *
 *  - In the C/C++ Build page
 * 
 *    - Set the Optimization Level to -Os
 * 
 * In System Library project (small_hello_world_syslib):
 *  - In the C/C++ Build page
 * 
 *    - Set the Optimization Level to -Os
 * 
 *    - Define the preprocessor option ALT_NO_INSTRUCTION_EMULATION 
 *      This removes software exception handling, which means that you cannot 
 *      run code compiled for Nios II cpu with a hardware multiplier on a core 
 *      without a the multiply unit. Check the Nios II Software Developers 
 *      Manual for more details.
 *
 *  - In the System Library page:
 *    - Set Periodic system timer and Timestamp timer to none
 *      This prevents the automatic inclusion of the timer driver.
 *
 *    - Set Max file descriptors to 4
 *      This reduces the size of the file handle pool.
 *
 *    - Check Main function does not exit
 *    - Uncheck Clean exit (flush buffers)
 *      This removes the unneeded call to exit when main returns, since it
 *      won't.
 *
 *    - Check Don't use C++
 *      This builds without the C++ support code.
 *
 *    - Check Small C library
 *      This uses a reduced functionality C library, which lacks  
 *      support for buffering, file IO, floating point and getch(), etc. 
 *      Check the Nios II Software Developers Manual for a complete list.
 *
 *    - Check Reduced device drivers
 *      This uses reduced functionality drivers if they're available. For the
 *      standard design this means you get polled UART and JTAG UART drivers,
 *      no support for the LCD driver and you lose the ability to program 
 *      CFI compliant flash devices.
 *
 *    - Check Access device drivers directly
 *      This bypasses the device file system to access device drivers directly.
 *      This eliminates the space required for the device file system services.
 *      It also provides a HAL version of libc services that access the drivers
 *      directly, further reducing space. Only a limited number of libc
 *      functions are available in this configuration.
 *
 *    - Use ALT versions of stdio routines:
 *
 *           Function                  Description
 *        ===============  =====================================
 *        alt_printf       Only supports %s, %x, and %c ( < 1 Kbyte)
 *        alt_putstr       Smaller overhead than puts with direct drivers
 *                         Note this function doesn't add a newline.
 *        alt_putchar      Smaller overhead than putchar with direct drivers
 *        alt_getchar      Smaller overhead than getchar with direct drivers
 *
 */


#include "sys/alt_stdio.h"
#include "HAL/inc/io.h"
#include "system.h"
#include <stdint.h>
volatile uint64_t SIGMA10 [128] = {

		0x00000093c383f622,
		0x00000177d4d6a050,
		0x000002d568b75ee8,
		0x000004e986d51a52,
		0x0000080de57c65f0,
		0x00000cc565ff4655,
		0x000013cd8779da03,
		0x00001e3692a4da7c,
		0x00002d84ca966585,
		0x000043dd985ab6ea,
		0x0000644476bd4d9a,
		0x000092ec5c579af9,
		0x0000d5a386a75d1b,
		0x00013460da188e26,
		0x0001b9fb860bf00b,
		0x000275173a294ce7,
		0x00037950ef64439d,
		0x0004e0b9ffc54716,
		0x0006cdb0e8d37fb7,
		0x00096d2878a77b11,
		0x000cf96f1e786630,
		0x0011bd886c0461e0,
		0x0018192a435e06f2,
		0x0020856d6ad78ee6,
		0x002b9a3e0133a9a6,
		0x003a149341c5ce68,
		0x004cdd6eec7f997c,
		0x0065119b419ee230,
		0x00840a12b4549600,
		0x00ab64ee45d6c1a0,
		0x00dd0ea7118a1c00,
		0x011b4b655777b8c0,
		0x0168c003e5541520,
		0x01c87a5b02a5cc40,
		0x023df8531e4e6b60,
		0x02cd2d2ecb09dc00,
		0x037a846ead9c9820,
		0x044ae1aa87913680,
		0x05439cba34c99280,
		0x066a7991d3cc0600,
		0x07c59b46b9855140,
		0x095b71d028be6d80,
		0x0b32a23f63559c00,
		0x0d51e95e34b5e980,
		0x0fbff8e0630ebe80,
		0x12834f998613d500,
		0x15a20d72bc4aa300,
		0x1921c426fb2e2800,
		0x1d0746150380f400,
		0x215674b6b4599c00,
		0x26121081c9dc1a00,
		0x2b3b8c197d0aa400,
		0x30d2e4c700980200,
		0x36d6822570685c00,
		0x3d431ecaaa246400,
		0x4413bb795f483000,
		0x4b419e12dd7f6c00,
		0x52c45d139301a400,
		0x5a91f7e8de48e000,
		0x629efbe748f55400,
		0x6adeb51cf534ec00,
		0x734369b46cc9a400,
		0x7bbe9e1fe868f000,
		0x84415fdbd9d06000,
		0x8cbc9447556fb000,
		0x952148decd046800,
		0x9d61021479440000,
		0xa56e0612e3f07000,
		0xad3ba0e82f37b000,
		0xb4be5fe8e4b9e800,
		0xbbec428262f12000,
		0xc2bcdf311814f000,
		0xc9297bd651d0f800,
		0xcf2d1934c1a15000,
		0xd4c471e2452eb000,
		0xd9eded79f85d3800,
		0xdea989450ddfb800,
		0xe2f8b7e6beb86000,
		0xe6de39d4c70b3000,
		0xea5df08905eeb800,
		0xed7cae623c258800,
		0xf040051b5f2aa000,
		0xf2ae149d8d837800,
		0xf4cd5bbc5ee3c800,
		0xf6a48c2b997af800,
		0xf83a62b508b41800,
		0xf9958469ee6d6000,
		0xfabc61418d6fd000,
		0xfbb51c513aa82800,
		0xfc85798d149cc800,
		0xfd32d0ccf72f8800,
		0xfdc205a8a3eaf800,
		0xfe3783a0bf939800,
		0xfe973df7dce55000,
		0xfee4b2966ac1b000,
		0xff22ef54b0af5000,
		0xff54990d7c62a800,
		0xff7bf3e90de4d000,
		0xff9aec60809a8000,
		0xffb3208cd5b9c800,
		0xffc5e96880739000,
		0xffd463bdc105b800,
		0xffdf788e5761d000,
		0xffe7e4d17edb5800,
		0xffee407356350000,
		0xfff3048ca3c0f800,
		0xfff690d34991e000,
		0xfff9304ad965d800,
		0xfffb1d41c2741000,
		0xfffc84aad2d51000,
		0xfffd88e488100800,
		0xfffe44003c2d6800,
		0xfffec99ae820c800,
		0xffff28583b91f800,
		0xffff6b0f65e1b800,
		0xffff99b74b7c0800,
		0xffffba1e29dea000,
		0xffffd076f7a2f000,
		0xffffdfc52f947800,
		0xffffea2e3abf7800,
		0xfffff1365c3a0800,
		0xfffff5eddcbce800,
		0xfffff9123b643000,
		0xfffffb265981e800,
		0xfffffc83ed62a800,
		0xfffffd67feb55000,
		0xfffffdfbc2394800,
		0xfffffe5ad4d8f000


};

volatile uint64_t PULSE_RESPONSE_VALS [2] = { //1, 0.0
		//0x0000000001000008, //1, 0.0
		//0x0000000000000008,
		//0x0000000001000008, //1, 0.1
		//0x00000000001a0008
		//0x0000000001000008,//1, 0.2
		//0x0000000000330008
		0x0000000001000008, //1, 0.3
		0x00000000004d0008
		//0x0000000001000008, // 0.4
		//0x0000000000660008
		//0x0000000001000008, //1, 0.8
		//0x0000000000cd0008
		//0x0000000001000008,//1, 0.5
		//0x0000000000800008


};

int main()
{
  //printf("Hello from Nios II!\n");
	//assigning values to SIGMA6:


	volatile uint32_t * ocm_base = (uint32_t *) ON_CHIP_MEM_BASE;
	volatile uint32_t total_bits = 0;// = 0x1234DEAD;

	//writing to ocm to see if it works:
	//*(ocm_base) = value;
	//*(ocm_base+1) = value;
	//*(ocm_base+2) = value;
	//*(ocm_base+3) = value;

	//writing sigma_6 values into ocm:
	for(int i = 0; i < 128; i = i + 1){ //this starts at 1C0;
		*(ocm_base+i*4+864) = (uint32_t)(SIGMA10[i] >> 32); //upper
		*(ocm_base+i*4+1+864) = (uint32_t)SIGMA10[i]; //lower //1c0
	}
	//writing channel: channel starting at 1580 and 1584:  1376:
	for(int i = 0; i < 2; i = i + 1){
		*(ocm_base+(i)*4+1376) = (uint32_t)(PULSE_RESPONSE_VALS[i] >> 32); //upper
		*(ocm_base+(i)*4+1+1376) = (uint32_t)PULSE_RESPONSE_VALS[i]; //lower //1c0
	}

	//found the location of the actual hex file!!
	// the noise channel location starts at D80, D84
	//conversion: D80 =
	//D84 =
	//1600 =
	//2c0 maps to 1600
	volatile uint32_t total_bit_errors = 0;
	volatile double BER = 0.0;
	//printing a range of values to see where the total_bits are located
	volatile int count = 0; //should be at 144
	//while(count < 146){
		//total_bits = *(ocm_base+130+count);
		//total_bit_errors = *(ocm_base+404);
		*(ocm_base+1440) = 0x1;
		*(ocm_base+1440) = 0x2;

		total_bit_errors = *(ocm_base+864);
		total_bit_errors = *(ocm_base+865); //this is 8 //this is 6991a1e1
		total_bits = *(ocm_base+1408); //this is 12 //this is 2C0 in quartus total bits:
		total_bit_errors = *(ocm_base+1412); // this is 14 1610
//count = count + 2;
		//BER = ((double) total_bit_errors) / ((double) total_bits);
		//alt_printf("total bits: %x\n", total_bits);
		//alt_printf("total bit errors: %x\n", total_bit_errors);
	//}
	alt_printf("total bit errors: %x\n", total_bit_errors);
  return 0;
}
